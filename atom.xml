<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QH2333&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.qh2333.com/"/>
  <updated>2020-11-18T15:51:41.704Z</updated>
  <id>https://blog.qh2333.com/</id>
  
  <author>
    <name>QH2333</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>具象网络科普(1) - 局域网</title>
    <link href="https://blog.qh2333.com/2020/11/15/tangible-network-01/"/>
    <id>https://blog.qh2333.com/2020/11/15/tangible-network-01/</id>
    <published>2020-11-15T11:13:42.000Z</published>
    <updated>2020-11-18T15:51:41.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>百闻不如一见</p></blockquote><a id="more"></a><h2 id="前言">前言</h2><p>19世纪60年代，在美国几所大学里，有人使用通信线缆连接起了一系列的计算机，然后编写了收发数据的程序，使得这些计算机之间可以互相交换信息，由此诞生了最早的一批“网络”。经过接近60年的发展，如今网络已经遍布世界，成为现代社会的“信息基础设施”。但是同时，网络的结构也变得极度复杂：现在即使拿出一张中小型网络的结构图来，人们也会发现它的内部充满了“调制解调器、网桥、交换机、AP、路由器、网关”等各式设备，不像它最初诞生时的那样简洁。</p><p>这种“复杂性”使得实际网络中发生的一切离普通人原来越远。一个普通人可能在家里接触过“家用无线路由器”，但却没有机会去了解它为了实现“让家里上网”，究竟完成了什么工作。一个计算机专业的学生可能在计算机网络课中学习了协议、分层结构、路由等知识，但也很难在现实中接触的设备中找到对应（当然这主要是因为遇到了不太优秀的老师），从而觉得具象化的计算机网络是一门抽象的学科。好在这些“复杂”和“抽象”都只是一种错觉：一方面，当今的网络本质上和它刚诞生的时候没有太多区别；另一方面，再复杂的功能都是通过实实在在、看得见摸得着的网络设备来完成的。这一系列博文中，我希望架起<strong>抽象网络知识</strong>和<strong>具象物理世界</strong>桥梁，科普一些有趣的知识，但也不希望写一份网络讲义。</p><h2 id="什么是网络">什么是网络</h2><p>在解决问题前，我们最好先弄清楚要解决的是什么问题。所以在介绍网络前，我们最好先了解一下网络的作用是什么，换句话说：<em>为什么要有网络？</em>大部分教材中都会提到<strong>数据通信</strong>和<strong>资源共享</strong>两种作用，我认为这是比较精当的，不管是发信息、发邮件、网上冲浪，还是玩网络游戏、看视频、下载文件，都离不开这两者的范畴。</p><p>网络让人们互相通信、共享资源，而在计算机的世界中，信息、资源都是以数据形式存在的，于是我们也可以说，网络为连接到其上的设备提供提供<strong>数据交换</strong>的服务。</p><p>结构上，我愿意把网络看作一个<strong>计算机系统</strong>。我们仍可以像60年前那样，认为网络里包括的只是一些<strong>计算机</strong>和连接这些计算机的<strong>通信线路</strong>，这么说虽然不一定完全准确，但也已经足够了。没错，大部分网络设备做的事情和计算机没有区别：路由器无非是收到数据后决定接下来把它转发到哪里去，或是对数据的内容做一些检查，确保安全性。还有一小部分网络设备则充当通信线路的职责：整理信号让它可以发的更远，或是转换信号的格式。我们考虑这类设备的时候可以直接用电线来代替它们。</p><p>网络里的计算机希望互相交换数据，这肯定不能在无序的情况下实现。就像道路交通一样，网络中的计算机需要遵守一定的规则，才能保证效率和安全：按什么格式发送数据、收到别人的数据后做什么、收到错误的数据后怎么办、如何保证数据不被人偷看？这些规则通常被人们记录在文档里，称为<strong>协议</strong>，实际中人们需要编写相应的<strong>程序</strong>来实现这些协议。</p><p>总结一下，<strong>网络就是一个由计算机、通信线路、协议、实现协议的程序组成的计算机系统</strong>，这个系统往小里说可以是家里的<strong>局域网</strong>，往大里说可以是覆盖全球的<strong>广域网</strong>（例如Internet）。</p><p>在这个系列的最开始，我将从大家最熟悉的以太网开始介绍。即使没有听说过这个名字，你大概也会每天都接触到它。</p><h2 id="抽象通信线路和计算机">抽象：通信线路和计算机</h2><p>正式开始之前，还需要介绍几个概念，好确保大家对一些基础知识有一定印象。首先需要明确的是：<em>通信线路到底是什么？</em></p><p>由于是科普性质，我会把讨论的东西限制在“常见”的范围内，所以就认为通信线路一般是<strong>双绞线</strong>或是<strong>光纤</strong>好了。</p><h3 id="双绞线">双绞线</h3><p>双绞线就是人们口中的网线，大多数人应该都见过，接口处是方形的透明塑料做的，还有一个小卡口。</p><p><img src="https://file.qh2333.com/blog_cache/tangible-network-01/Rj45plug-8p8c.png" alt="Figure 1. 网线接口" width="60%"/></p><p>网线通过机械方式插在电脑上的网口里。网口是一个带凸起的方形插槽，运行时通常还会有闪烁的指示灯。</p><p><img src="https://file.qh2333.com/blog_cache/tangible-network-01/Ethernet_Connection.jpg" alt="Figure 2. 运行中的网口" width="60%"/></p><p>双绞线本质上只是把8根细小的铜电线包在一根线的内部，这8根线两两一组分为四组，每组的两根线互相缠绕在一起，所以得名“双绞线”（我们不需要知道这么做的目的）。从电线的角度看：如果一个人改变了一组电线上的电压，那另一个人就可以在电线的另一头检测到这一变化，于是电压的变化就可以用来传递信息。信息传递的最小单位是bit，一旦我们确定一bit信息持续的时间，就可以通过不断改变、检测电压来实现信息的收发。把电线组装成网线，把网线接在两台计算机之间，规定四组电线的收发分工，让计算机来自动改变、检测网线上的电压，这就是网线在计算机之间传输数据的基本模式。</p><p>为了简化思维负担，我们可以去掉“电线、电压”这些物理意义，<strong>暂时</strong>只把网线抽象成一个双向的管道：当网线连接在两台计算机之间时，任意一方向管道中注入数据（改变电压），另一方都会从管道中接收到这些数据（检测电压改变）。</p><h3 id="光纤">光纤</h3><p>光纤通常是黄色的细小线路（相对于双绞线而言），对我们而言，只需要知道光纤发送数据的能力远远高于双绞线就可以了。</p><h2 id="尝试在两台计算机间收发数据">尝试在两台计算机间收发数据</h2><p>拥有一根可以双向收发数据的网线后，我们就可以基于它构建网络了。想象一个最基础的网络：两台计算机外加一根网线，网线的两端分别接在两台计算机的网口上。</p><p><img src="https://file.qh2333.com/blog_cache/tangible-network-01/topology1.svg" alt="Figure 3. 简单拓扑"/></p><p>那么如何在两台计算机之间交换信息呢，比如说Alice想要给Bob发送一个文件？很显然，Alice不会时时刻刻向Bob发送文件，所以她必须让Bob知道这个文件什么时候开始发送，以及文件的长度有多长。在我们的网络中，可以规定一个特殊的比特序列，称为<strong>同步码</strong>，并且让Bob一直在网线上监听，一旦发现Alice发送了同步码，Bob就知道后面的内容是Alice发来的文件信息。至于文件长度的确定，我们也可以沿用类似的方法：规定另一个特殊的比特序列，称为<strong>结束码</strong>，一旦Bob发现接收的数据中出现了这串比特序列，就知道文件已经发送完毕。</p><p>如果遇到很长的文件，我们怎么处理呢？首先是不做特殊处理的方法：将<strong>整个</strong>文件从头到尾发送到网线上，就好像传输水流一样；另外我们也可以将文件分块，然后从前到后把分块<strong>逐块</strong>发送到网线上，就好像传送快递包裹一样。看起来第一种方法比较直接，而第二种方法稍显麻烦，但网络中实际采用的确是第二种方法。之所以这么做，很大的一个原因是前一种方法灵活性太差：如果Alice同时需要给Bob发送两个文件，第一种方式下只能发完一个再发另一个。极端的情况下，一个大文件后紧跟着一个小文件，那小文件即使可以在0.1s内传输完成，它也必须先等大文件传输结束。如果用后一种方法，Alice可以选择轮流发送两个文件的一小块内容，给人一种两个文件同时在发送的错觉，这称为<strong>并发(Concurrency)</strong>。</p><p>用术语来说，文件的每个小块称为<strong>分组</strong>或<strong>包(Package)</strong>，而这种传输方式称为<strong>分组传输</strong>。世界上的几乎所有网络流量都是通过分组方式传输的。</p><p>举例来说，现在Alice需要给Bob发送一个2000Byte的文件，我们事先规定一个分组最多只能长1500Byte，并且Bob知道文件一共有2000Byte。Alice决定把这个文件分成2份（第一份1500Byte长，第二份500Byte长），然后再把每一份文件内容分别打包成分组（也就是在实际内容前面附加同步码、在实际内容后附加结束码），发送到网线上。另一端的Bob首先接收到同步码，然后开始接收文件的实际内容，直到收到结束码。当Bob完整地收到两个分组后，他也就知道文件已经接收完成。</p><h2 id="如果需要连接更多计算机呢">如果需要连接更多计算机呢</h2><p>我们已经可以在两台计算机之间传送信息了，但如果出现了第三台计算机呢？下面是两种简单的拓展。</p><p><img src="https://file.qh2333.com/blog_cache/tangible-network-01/topology2.svg" alt="Figure 4. 尝试扩展网络"/></p><p>左边的图中Charlie连接到Alice的计算机上，Alice再连接到Bob，但这么一来Alice的任务就会变得繁重：她除了自己需要的信息外，还必须帮Charlie和Bob转发他俩之间的信息。右边图中每两个人之间都相互连接，但这样带来的后果是每个人的计算机都必须有两个网络接口。</p><h3 id="广播和以太网">广播和以太网</h3><p>正确的做法是让Charlie直接连接到Alice和Bob之间的网线上。</p><p><img src="https://file.qh2333.com/blog_cache/tangible-network-01/topology2-1.svg" alt="Figure 5. 广播网络"/></p><p>为什么能这么做呢？别忘了网线的本质是电线，电压改变后在电线的任何一处都可以测量到变化，也就是说接在同一根网线上的每一台计算机，发送的信息都可以让其他所有计算机接收到！这种信息发送方式称为<strong>广播(Broadcast)</strong>。现在我们有必要更新一下之前网线是“双向管道”的认知，就像空气是传播声音的媒介一样，网线似乎可以看作是传播信息的媒介，这种网络的发明者认为假想的光传播媒介“以太”很符合网络的特点，所以把这种网络命名为<strong>以太网(Ethernet)</strong>。</p><h3 id="mac地址">MAC地址</h3><p>广播的引入带来了新的问题。当线路上只有Alice和Bob两个人时，不管是谁发送的信息，都只能由另一个人接收，不存在任何歧义。但加入Charlie后，Alice发送的数据Bob和Charlie都可以收到，怎么确定这数据到底该由谁来接收呢？答案的灵感可以从邮件中找到，寄件时我们会在信封上填写发件地址和收件地址，只有拥有收件地址的那个人才可以收件并把邮件打开。发件地址和收件地址可以认为是收发双方的一种“标识符”，同样的我们也可以为网络中的设备分配不同的标识符，这称为设备的<strong>物理地址</strong>或<strong>MAC地址</strong>。</p><p>MAC地址是一个长48位的二进制数，通常我们用下面这种十六进制格式来书写MAC地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12:34:56:78:9A:BC</span><br></pre></td></tr></table></figure><p>实际上，MAC地址标记的是<strong>网络接口</strong>（包括但不限于插网线的那个网口），如果一台计算机有两个网口，那就会有两个MAC地址。通过某种合理的分配方式，我们可以认为任意两个网口的MAC地址相同的概率为0。网口必定是属于网络中某个计算机的，间接地来说我们就用MAC标记了网络中的计算机。</p><h3 id="封装">封装</h3><p>既然有了标记网络中计算机的手段，我们下一步就需要把收发双方的MAC地址添加到分组中。</p><p>假设以太网中一个分组最多可以携带1500Byte的信息，在没有MAC地址时，这1500Byte全都可以用于传递用户的信息（比如文件的某一片段），现在有了MAC地址，我们必须<strong>至少</strong>分出12Byte来表示收发双方的MAC地址（48/8*2 = 12），所以<strong>最多</strong>只剩1488Byte可以用来传递用户的信息。</p><p>分配好空间使用后，我们还需要确定把这12Byte地址信息放在哪里。约定俗成地，这部分内容会出现在整个分组的最前端。实际的以太网中，除了12Byte地址信息外还有4Byte的其他信息（<code>Type</code>），紧挨着地址信息出现。这样，一个以太网报文的大致格式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+-------------------+-------------+-----------+</span><br><span class="line">| 6 Byte Destination MAC | 6 Byte Source MAC | 4 Byte Type | User Data |</span><br><span class="line">+------------------------+-------------------+-------------+-----------+</span><br></pre></td></tr></table></figure><p>以太网规定了以何种格式发送数据（还有许多其他内容，比如MAC地址），正如最初所说的，我们说以太网是一种<strong>协议</strong>。上面所说的这种“<strong>在用户数据(User data)前，添加协议有关的数据</strong>”的行为，称为<strong>封装(Encapsulation)</strong>，协议有关的数据通常称为<strong>报头(Header)</strong>。“封装”一名的由来非常形象：以太网报头就像是一个容器，把用户数据打包装在其内部。</p><p>经过封装后，数据就又可以在以太网中放心地传输了。网络中的每台计算机接收到广播来的分组后，查看分组中填写的<strong>目的MAC地址(Destination MAC)</strong>，如果与自身的MAC相符，就收下这个分组；否则不再做任何其他处理（相当于丢弃）。</p><h3 id="hub">Hub</h3><p>在行为层面上，我们的以太网已经可以愉快地运行，但是还存在一个实现上的小问题：市面上并没有三个接头的网线，所以Clarlie要怎么把他的网线接在Alice与Bob之间已经存在的网线上呢？</p><p>解决这一问题的是一种很简单的网络设备：以太网Hub</p><p><img src="https://file.qh2333.com/blog_cache/tangible-network-01/4_port_netgear_ethernet_hub.jpg" alt="Figure 6. 以太网Hub"/></p><p>如果你认识交换机的话，可能会觉得Hub和交换机外观很相似。就功能上而言，二者确实很相似，他们都把多台计算机接入同一个以太网中。但细究起来，Hub是一种比交换机古老得多的设备（以至于现在几乎已经不再使用了），它的内部结构极其简单：只是<strong>把每个双绞线插口中的8根线，分别连接到一起</strong>。这是一种纯物理层面的设备，使用最直接的方式连接了以太网。</p><p>到此为止，就是以太网最基础的运行原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;百闻不如一见&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="网络" scheme="https://blog.qh2333.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Aweful C/C++</title>
    <link href="https://blog.qh2333.com/2020/03/12/aweful-c/"/>
    <id>https://blog.qh2333.com/2020/03/12/aweful-c/</id>
    <published>2020-03-12T11:25:02.000Z</published>
    <updated>2020-03-12T13:00:12.905Z</updated>
    
    <content type="html"><![CDATA[<p>“混乱代码大赏”</p><a id="more"></a><p>　　C语言是一门非常古老又强大的语言，即使现在，“万物基于C语言”这句话也不是说说的。</p><p>　　由于C语言诞生的年代关系（1972年），和一众当今的“先进语言”相比它还是保留着最初的质朴。当然这种质朴换一个角度说就是暴力美学了，直来直往地暴露出底层硬件，甚至很多规定都是为了便于编译器实现才有的。C语言的这个特点让一代代程序员为之着迷，毕竟谁不想体验这种完全掌控机器的快感呢，同时也催生出了混乱代码这种新奇玩意。</p><p>　　虽然还没怎么开始写，但下面的代码恐怕都是不适合放到实际使用的。</p><h2 id="预编译">预编译</h2><h3 id="拆行">拆行</h3><p>　　实现一门新语言时，很重要的一个问题是怎么处理<strong>一个语句跨多行</strong>和<strong>一行多个语句</strong>这两种情况。关与一个语句跨多行这种情况，C语言的一种对策是允许将<strong>反斜杠[\]</strong>用作拆行的标记。在很多的编译器实现中，他们会在编译刚开始时搜索文件中所有<strong>连着的反斜杠和换行符</strong>，然后直接将它们<strong>全部删除</strong>。所以从道理上说，我们可以用反斜杠拆分C语言中的所有东西，包括预编译指令、标识符、字符串...（误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#in\</span></span><br><span class="line">clude&lt;st\</span><br><span class="line">dio.h\</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ma\</span><br><span class="line">in()</span><br><span class="line">&#123;</span><br><span class="line">    prin\</span><br><span class="line">tf(<span class="string">"Hello \</span></span><br><span class="line"><span class="string">world."</span>);</span><br><span class="line">    ret\</span><br><span class="line">urn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注释">注释</h3><p>　　由于预编译中删除注释发生地比宏定义展开更早，所以你无法宏定义一个注释！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“混乱代码大赏”&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="编程" scheme="https://blog.qh2333.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络迷思</title>
    <link href="https://blog.qh2333.com/2020/03/11/network-myth/"/>
    <id>https://blog.qh2333.com/2020/03/11/network-myth/</id>
    <published>2020-03-11T02:05:19.000Z</published>
    <updated>2020-11-14T14:32:34.789Z</updated>
    
    <content type="html"><![CDATA[<p>- 网连不上了。 - 为什么呢？</p><p>（一通操作后）</p><p>- 网又能连上了。 - 为什么呢？？？</p><a id="more"></a><p>　　初学网络时，想法总是又多又离奇，就差把每种设备每个设置都排列组合一下试试效果。尝试的结果有时能打开新世界的大门，更多时候都让我理解不能（深深为自己什么都不懂感到忧虑）。当然不仅是在搞事的时候，日常使用网络设备也伴随着很多这样那样的困惑。</p><p>　　后来发现，一些看起来奇怪的现象都可以用简单的网络原理来解释（没能把原理和现象联系起来，果然是菜爆了）。所以我就在这里记下那些和网络相关的小问题。</p><p>　　本文属于科普性质，没有太多术语。</p><p>　　本文长期更新。</p><h2 id="始终达不到标称速率的网络">始终达不到标称速率的网络</h2><figure><img src="https://file.qh2333.com/blog_cache/network_myth/1.png" alt="We are upgrading to 10 Gigabit Internet!" /><figcaption aria-hidden="true">We are upgrading to 10 Gigabit Internet!</figcaption></figure><figure><img src="https://file.qh2333.com/blog_cache/network_myth/2.png" alt="But we can only expect 9.8 Gigiabit from the switch?" /><figcaption aria-hidden="true">But we can only expect 9.8 Gigiabit from the switch?</figcaption></figure><figure><img src="https://file.qh2333.com/blog_cache/network_myth/3.png" alt="Damn ISP always get an excuse!" /><figcaption aria-hidden="true">Damn ISP always get an excuse!</figcaption></figure><p>THERE IS OVERHEAD!!!</p><p>　　网速一直是一个比较玄学的概念，买宽带以后运营商最怕用户问这问那，所以总会多给那么百分十几的带宽，用于抵消各种不利因素，让网络看起来“跑满了”。可以自己搭建内网时就没有这种福利了，网络设备上写了多少速度那必不可能再多，从此满速网络成了奢望。那么，缺失的速度都去了哪里呢？</p><h3 id="网络协议开销">网络协议开销</h3><p>　　网络是一个充满协议的地方，为了确保网络的正常运转，网络协议在传送数据时需要知道很多附加信息：数据从哪里发出？应该被谁接收？数据的校验码是多少？通常，这些额外的数据会附加在有效数据上，并且通常不止有一组附加数据。网络术语中，每附加一次数据就是进行了一次<strong>封装</strong>。事实上，我们的数据从电脑内部到达网络接口时，已经经过了层层封装。</p><p>　　网络接口上传送的数据是多次封装后的数据，而我们需要的只是原始的数据。就像一辆卡车能运送10t快递包裹，但是去掉包装后拿到买家手里的货可能只剩下了8t。总传输速率1000Mbps的网络接口，去掉封装后的有效数据传输速率可能只剩960Mbps左右了。</p><h3 id="cpu">CPU</h3><p>　　曾经我从未想过CPU可能成为限制网络速度的因素之一，直到我在路由器上运行了<code>iperf3</code>测速工具。</p><h3 id="硬盘">硬盘</h3><p>　　硬盘自然不必多说，千兆网络100MB/s起步的传输速度已经逼近了机械硬盘的极限，不久以后的万兆网络也会将SATA接口送进历史。想要硬盘不拖后腿？那还是早日使用固态硬盘，最好还是NVMe或者PCIe接口的那种。</p><h2 id="满血信号和残血网速">满血信号和残血网速</h2><p>　　使用学校的公用Wi-Fi时，我发现一个奇怪的现象：同样是满格信号，有的教室网速很快（50Mbps+），有的教室网速就很一般（10Mbps以下）；至于那些信号都无法满格的教室，可能就连网都连不上了。</p><p>　　造成这个问题的主要原因是：学校里发射Wi-Fi信号的装置——<strong>无线AP</strong>，功率太大了！很显然这是一个违背常识的原因，大功率的AP明明应该带来更好的网络质量才对啊！问题在于，AP和移动设备间的通讯并不是单向的。AP的功率很容易提升，于是很大范围内的移动设备都可以接收到它发射的Wi-Fi信号；但反过来说，移动设备的信号发射功率不可能大幅提升（要电池的嘛）。这就造成了在某一片区域中，移动设备能收到AP信号，但AP很难收到移动设备的信号的现象，一旦移动设备进入到了这片区域，即使设备自认为信号不错，双方的通信也无法顺畅进行。</p><p>　　但是，就算是下载文件时，AP和移动设备间的通信也是双向的吗？确实，就拿用手机下载文件的例子来说，这个文件会被分割成很多小片段，然后从服务器上逐一传送过来。这些小片段在传送过程中可能会丢失或者发生错误，服务器为了确保手机能够正确收到所有片段，就要求手机每收到一个片段后向服务器发送一条“确认收到”的信息。一旦某一条“确认收到”的信息迟迟没有被服务器收到，服务器就会认为这个文件片段丢失了，并把它重新发送一次。如果手机发回的“确认收到”不能被AP接收到，那自然不会被网络另一头的服务器收到，于是服务器等待的时间就变长了，网速也就变慢了。</p><p>　　在最合理的情况下，AP在增强信号发射功率的同时也应该同时增强自己接收信号的能力，使得实际的网络质量和信号强度大致呈正比。然而，增强信号接收能力需要更优秀的信号识别算法，这可不是人人都能做的，相比于简单的增强功率简直是吃力不讨好，这自然就催生出了只增强功率，让人乍一看觉得网很好的“作弊”行为。</p><hr />]]></content>
    
    <summary type="html">
    
      &lt;p&gt;- 网连不上了。 - 为什么呢？&lt;/p&gt;
&lt;p&gt;（一通操作后）&lt;/p&gt;
&lt;p&gt;- 网又能连上了。 - 为什么呢？？？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络" scheme="https://blog.qh2333.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的作业跟踪工具</title>
    <link href="https://blog.qh2333.com/2020/03/04/endless-homework/"/>
    <id>https://blog.qh2333.com/2020/03/04/endless-homework/</id>
    <published>2020-03-04T01:57:03.000Z</published>
    <updated>2020-07-18T04:46:37.761Z</updated>
    
    <content type="html"><![CDATA[<p>叮！又有新作业了！</p><a id="more"></a><h2 id="背景">背景</h2><p>出于种种原因，某些老师/助教布置作业时的要求总是让人费解，同学们经常为作业的提交时间而争吵，甚至产生恐慌。今年在嘉里敦大学上课，一门课一个作业提交平台更是激化了这个问题带来的矛盾。</p><p>我认为，所有让同学理解作业时产生overhead的老师/助教，都该骂。</p><p>可惜能力有限，无法改变现状（如果怼的话，相信老师会让我考虑自己的前途的），只能做一个整合平台，尽力用最直观的方式让人了解作业的布置情况。</p><h2 id="这个工具可以干什么">这个工具可以干什么</h2><p>可以按照课程对作业进行分类，按提交时间对作业进行排序。每项作业都有明确的提交方式和提交时间，不同阶段的作业（普通作业、即将提交的作业、提交截止的作业）按照颜色进行区分。</p><h2 id="怎么实现的">怎么实现的</h2><p>做一个Web应用自然是最好的，这样一来部署上服务器以后大家就都可以方便地使用。各部分的技术选型，我是这么考虑的：</p><ul><li>技术上本着最简(tou)化(lan)的原则，我选择了基于Python的Flask框架，毕竟这个框架不需要多少行代码就能跑起来。</li><li>工具虽小，但也是个完整的Web应用，关于作业的各项信息就是业务信息了，肯定需要放在数据库中，我的服务器上之前就安装了MySQL，于是干脆就地取材。</li><li>出于减轻服务器压力的考量（虽然本来就不会有什么压力），我决定不让服务器直接在后端渲染好页面，而是返回JSON数据，让浏览器里的JavaScript完成主要的HTML渲染工作。</li><li>至于前端，手写样式想起来就让人头皮发麻，那就只好用Bootstrap这种样式库，套个模板我还是会的。</li></ul><p>当然，说白了这就是一个采用Flask后端、MySQL数据库，基于Ajax技术实现的Web应用。不过前面这句话里充满了吓人的术语，我还是不说的好。</p><h3 id="数据库">数据库</h3><p>因为这暂时还是一个非常简单的工具，我并没有考虑用户、权限、作业所属的班级这些乱七八糟的东西（其实只是偷懒）。整个数据库里只有<strong>作业信息</strong>一张表，自然也就不需要复杂的数据库设计。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`homework_info`</span> (</span><br><span class="line">  <span class="string">`rec_id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`assigntime`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`detail`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`deadline`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`method`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`rec_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">9</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure><h3 id="flask应用框架">Flask应用框架</h3><p>Flask的使用非常简单，我们只需要导入<code>flask</code>模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask</span><br></pre></td></tr></table></figure><p>然后像官方示例那样，创建一个Flask应用对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application = flask.Flask(__name__)</span><br></pre></td></tr></table></figure><p>再创建一些页面路由，随便返回些什么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@application.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Someting"</span></span><br></pre></td></tr></table></figure><p>最后自己写个main，让Flask应用运行起来就好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    application.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">7777</span>)</span><br></pre></td></tr></table></figure><h3 id="flask路由">Flask路由</h3><p>看得出来，上面的框架里只有页面路由的部分是我们需要修改的。如果只需要实现一个作业信息展示的功能，那一共需要配置两条路由，一条用来返回页面的HTML框架，另一条用来返回页面里的数据。</p><p>关于返回HTML框架的这条路由，我们可以预先写好一份HTML文件，让Flask在需要的时候直接调取返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@application.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> flask.render_template(<span class="string">'index.html'</span>)</span><br></pre></td></tr></table></figure><p>返回数据的这条路由实际上定义了一个Web API，地址是<code>/data</code>。当有人访问这个API时，我们需要去读取数据库中所有作业的信息，然后把读到的内容打包成一个JSON字符串，再返回。读数据库的代码网上有很多，我这里就直接写成一个函数调用了，看起来清晰不少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@application.route("/data")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data</span><span class="params">()</span>:</span></span><br><span class="line">    rst = flask.make_response(get_json())</span><br><span class="line">    <span class="keyword">return</span> rst</span><br></pre></td></tr></table></figure><h3 id="前端html">前端HTML</h3><p>前端的HTML代码只需要负责框架的搭建，所以除去引入JS、CSS的标记外，整个页面写这么几句就好。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span>SWJTU CS_2017 Homework<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"data"</span> <span class="attr">class</span>=<span class="string">"container-sm"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="前端javascript">前端JavaScript</h3><p>前端最主要的部分在JavaScript代码中。整个代码的思路其实非常简单：在HTML和CSS加载完成后，通过后端提供的<code>/data</code>这一Web API，拿到关于作业的所有数据，然后把这些数据解析成前端的HTML元素，插入页面之中。</p><p>向页面中插入HTML元素的方法有很多种，但它们的本质基本都相同。浏览器将一个HTML页面称为一个文档，然后文档被表示成元素节点的树状结构，称为<strong>文档树</strong>，通过一套名为<strong>DOM</strong>的API访问。插入元素，最朴素的做法就是找到文档树中的一个目标元素节点（通常是新插入元素节点的父节点），然后让新的元素节点成为其子节点，我在这里使用的就是这种方法。不幸的是，这种方法虽然看起来既标准又正统，但离完美差的很远。JS大牛Douglas Crockford在<em>《JavaScript语言精粹》</em>一书中认为</p><blockquote><p>DOM规范制定得很拙劣并且实现互不一致。</p></blockquote><p>事实也确实是这样。查找目标元素节点的操作需要遍历文档树，这在大型页面里是一项很耗费时间的操作。找到目标元素节点后，为了创建并在其中插入子节点，JavaScript代码中会<strong>大量、反复</strong>地出现<code>createElement()</code>、<code>setAttribute()</code>、<code>appendChild()</code>这些函数。而这些函数的调用又是很不层次化的，离清晰明了的HTML语言相距甚远。</p><p>更好的一种方法就显得很暴力，我们可以提前为待插入的内容编写好一份HTML<strong>模板</strong>代码，将其保存成字符串。需要插入时，只需要把目标元素节点的<code>innerHTML</code>属性置为模板字符串，浏览器就会自动完成解析操作。不管对人还是对电脑，这种方法效率都高了很多。后续我也许会尝试这种方法。</p><h2 id="最后">最后</h2><p>这篇Blog的正文是2020.7完成的，但其实这个工具在四个月前就写好了，只不过一直咕咕咕。（逃</p><p>你可以在我的Github上找到这个工具的<a href="https://github.com/QH2333/homework_tracker" target="_blank" rel="noopener">源代码</a>，欢迎尝试。</p><hr />]]></content>
    
    <summary type="html">
    
      &lt;p&gt;叮！又有新作业了！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网站" scheme="https://blog.qh2333.com/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>文档和教程</title>
    <link href="https://blog.qh2333.com/2020/02/22/doc-and-tutorials/"/>
    <id>https://blog.qh2333.com/2020/02/22/doc-and-tutorials/</id>
    <published>2020-02-22T02:41:53.000Z</published>
    <updated>2020-03-29T08:50:15.224Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近学的东西比较杂乱，其中像Web、Python、Data Mining这类东西又有数不清的框架，寻找合适的学习资料有种披荆斩棘的感觉。所以，我在这里记录下那些我觉得优秀的文档和教程，当作一个索引。</p><a id="more"></a><p>　　注：这里的推荐默认你具有外网访问条件，且优先列出官方的或者英文的资源。</p><h2 id="web">Web</h2><p><a href="https://www.youtube.com/playlist?list=PLhQjrBD2T382hIW-IsOVuXP1uMzEvmcE5" target="_blank" rel="noopener">Harvard_CS50's Web Programming with Python and JavaScript</a></p><h3 id="htmlcss">HTML/CSS</h3><p><a href="https://developer.mozilla.org/" target="_blank" rel="noopener">Mozilla_MDN Web Docs</a>（<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN Web文档</a>）</p><p><a href="https://material.io/" target="_blank" rel="noopener">Google_Material Design</a></p><h3 id="jquery">jQuery</h3><h3 id="bootstrap">Bootstrap</h3><p><a href="https://getbootstrap.com/docs/4.4/getting-started/introduction/" target="_blank" rel="noopener">Official Documentation</a></p><h3 id="echarts">ECharts</h3><p><a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="noopener">官网</a></p><hr /><h2 id="cc">C/C++</h2><p><a href="http://www.cplusplus.com/" target="_blank" rel="noopener">cplusplus.com</a></p><p><a href="https://en.cppreference.com/" target="_blank" rel="noopener">CPP Reference</a> （<a href="https://zh.cppreference.com/" target="_blank" rel="noopener">中文版</a>）</p><h3 id="keil-cx51">Keil Cx51</h3><p><a href="http://www.keil.com/support/man/docs/c51/c51_intro.htm" target="_blank" rel="noopener">C51 Docs</a></p><hr /><h2 id="c">C#</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/" target="_blank" rel="noopener">C# 文档</a></p><p><a href="https://channel9.msdn.com/Series/CSharp-101/" target="_blank" rel="noopener">C# 101 (Tutorial)</a></p><hr /><h2 id="python">Python</h2><h3 id="lanuage">Lanuage</h3><p><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP63WbdFxL8giv4yhgdMGaZNA" target="_blank" rel="noopener">MIT_6.0001</a></p><p><a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a>（<a href="https://docs.python.org/zh-cn/3/tutorial/index.html" target="_blank" rel="noopener">Python官方中文教程</a>）</p><p><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">The Python Standard Library</a>（<a href="https://docs.python.org/zh-cn/3/library/index.html" target="_blank" rel="noopener">Python标准库</a>）</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">Python3 Cookbook</a></p><h3 id="numpy">Numpy</h3><p><a href="https://youtu.be/V0D2mhVt7NE" target="_blank" rel="noopener">Intro to Numerical Computing with NumPy</a></p><h3 id="pandas">Pandas</h3><p><a href="https://pandas.pydata.org/" target="_blank" rel="noopener">Official Website</a></p><p><a href="https://pandas.pydata.org/docs/getting_started/10min.html" target="_blank" rel="noopener">Getting Started</a></p><p><a href="https://pandas.pydata.org/docs/reference/index.html" target="_blank" rel="noopener">API Reference</a></p><h3 id="geopandas">geopandas</h3><p><a href="https://geopandas.org/" target="_blank" rel="noopener">Documentation</a></p><h3 id="matplotlib">Matplotlib</h3><p><a href="https://matplotlib.org/" target="_blank" rel="noopener">Official Website</a></p><p><a href="https://matplotlib.org/tutorials/index.html" target="_blank" rel="noopener">Tutorial</a></p><p><a href="https://matplotlib.org/contents.html" target="_blank" rel="noopener">Documentation</a></p><h3 id="folium">Folium</h3><p><a href="https://python-visualization.github.io/folium/" target="_blank" rel="noopener">Documentation</a></p><hr /><h2 id="data-science">Data science</h2><h3 id="hadoop">Hadoop</h3><p><a href="http://file.qh2333.com/books/Hadoop%20-%20The%20Definitive%20Guide,%204th%20Edition.pdf" target="_blank" rel="noopener">Hadoop: The definite guide</a></p><h3 id="spark">Spark</h3><p><a href="https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">Spark 2.2.x 中文官方参考文档</a></p><p><a href="http://dblab.xmu.edu.cn/blog/1709-2/" target="_blank" rel="noopener">子雨大数据之PySpark入门教程</a></p><p><a href="http://spark.apache.org/docs/2.0.0/api/python/index.html" target="_blank" rel="noopener">PySpark API Docs</a></p><h3 id="flume">Flume</h3><p><a href="http://flume.apache.org/index.html" target="_blank" rel="noopener">Official Website</a></p><p><a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html" target="_blank" rel="noopener">Official Documentation</a> (<a href="https://flume.liyifeng.org/" target="_blank" rel="noopener">中文翻译</a>)</p><h3 id="kafka">Kafka</h3><hr /><h2 id="information-retrieval-search-engine">Information retrieval &amp; Search engine</h2><p><a href="https://nlp.stanford.edu/IR-book/information-retrieval-book.html" target="_blank" rel="noopener">Stanford_IR</a></p><hr /><h2 id="contributors">Contributors</h2><ul><li>KT.<ol type="1"><li>Material design</li></ol></li><li><em>More...</em></li></ul><hr />]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　最近学的东西比较杂乱，其中像Web、Python、Data Mining这类东西又有数不清的框架，寻找合适的学习资料有种披荆斩棘的感觉。所以，我在这里记录下那些我觉得优秀的文档和教程，当作一个索引。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="课程" scheme="https://blog.qh2333.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记家庭局域网的千兆升级历程</title>
    <link href="https://blog.qh2333.com/2020/02/12/upgrading-to-gigabit-lan/"/>
    <id>https://blog.qh2333.com/2020/02/12/upgrading-to-gigabit-lan/</id>
    <published>2020-02-12T13:15:00.000Z</published>
    <updated>2020-11-14T14:29:46.641Z</updated>
    
    <content type="html"><![CDATA[<p>百兆网线遇见千兆入户。</p><a id="more"></a><p><em>注1：唠嗑和吐槽居多，想学到什么东西大概不现实（逃</em></p><p><em>注2：前面很大的篇幅都是在介绍家里网络的演进，不想看的话可以直接跳到<a href="#%E5%8F%82%E6%95%B0%E8%B5%B7%E5%BA%95"><strong>参数起底</strong></a>部分</em></p><h2 id="开始的时候">开始的时候</h2><p>在很久以前，没有“提速降费”的黑暗年代里，我在家里一直用着广电和移动给穷人提供的小水管宽带。十多年来，网速从2Mbps磕磕绊绊提升到了2019年中旬的50Mbps。</p><p>那个时候，家里的网络结构大概是这个样子的：</p><p><img src="https://file.qh2333.com/blog_cache/upgrading-to-gigabit-lan/Topology1.svg" alt="P1. 网络拓扑1.0"/></p><p>有两个地方需要大概说一下。</p><ol type="1"><li><p>这图是用Visio画的，虽然用的是最新的2019版本，但是我依然没有找到任何类似于无线路由器的图标。从原理上讲，我们称呼为“无线路由器”的这个东西其实是<strong>极简路由器+交换机+无线AP</strong>的组合，这三个设备由厂家帮我们塞进了一个壳子里，所以在这里我也就画成三样东西的组合了。当然，如果有同学知道Visio怎么画出无线路由器，也可以在评论里告诉我（尽管tkl大佬指出我还没有评论区）。</p></li><li><p>手机用Wi-Fi上网，为什么电脑用的也是Wi-Fi呢？因为之前家里的台式电脑和无线路由器都放在客厅里，只不过分别位于两侧。这种情况下如果在客厅中间走一根网线那实在不够优雅，考虑到中间没有任何障碍物，所以台式机也就用无线网卡上网了（淘宝爆款300M无线网卡）。</p></li></ol><p>当时还是网络小白的我用着这套极简组网方案（一共只有一个猫和一个路由器，路由器甚至直接了WAN口），虽然总是隐隐觉得网速不怎么好，但毕竟能用嘛，也就没有多考虑。</p><h2 id="事情变得复杂起来">事情变得复杂起来</h2><p>除了一台主力台式机以外，家里还有一台退役的老台式。为了解决我和我爸同时占用电脑的问题，我们决定把老的台式机升级一下硬件继续用起来，位置呢在主卧里。家里的户型是L型的，之前的路由器和老台式机分别在L的两端，中间隔着两堵墙，无线方案行不通。还好装修的时候在墙里预留了网线，我只要去入户信息箱里找到那根网线然后手工压上水晶头就行（信息箱乱得很，辱骂装修施工队），老台式机成功有线连网。</p><p>这时候，爸妈在手机上上网的频率也高了起来，日益增长的网络需求同不充分的无线网络部署之间的矛盾凸显。为了初步解决这个问题，我又在主卧里接上了第二个淘宝爆款路由器，和客厅的主路由器形成级联。</p><p><img src="https://file.qh2333.com/blog_cache/upgrading-to-gigabit-lan/Topology2.svg" alt="P2. 网络拓扑2.0"/></p><p>淘宝爆款路由器很智能地为我划分了网段，客厅路由器位于<code>192.168.1.0/24</code>，主卧路由器位于<code>192.168.2.0/24</code>。</p><p>其实这套更新过的组网方案多少已经有了些问题，例如主卧内部二级路由的出现，导致连在二级路由上的设备无法在客厅主路由下访问。好在当时我也没有这种互访的需求，只要网络覆盖面积大了，那就皆大欢喜。</p><p>再往后我进了大学，次卧里的书桌上终于不用再堆满文具。在我报到之前，客厅的台式被移到了次卧里，好处是客厅变得宽敞了一些，坏处是隔了一堵墙的无线信号简直无法忍受。此外，我还新买了一台Surface，微软的无线网卡使用体验的确远高于淘宝爆款：同样隔墙，Surface可以正常上网，台式机却经常掉线。</p><p><img src="https://file.qh2333.com/blog_cache/upgrading-to-gigabit-lan/Topology2.1.svg" alt="P3. 网络拓扑2.1"/></p><p>原谅我在图里用了防火墙的图标，但是这堵墙对Wi-Fi的阻隔效果和防火墙实在没差！</p><h2 id="大跃进">大跃进</h2><p>大二暑假去NUS游学了大半个月，肉身翻墙感受到的国外互联网确实让我赞叹。7月4号到的新加坡，从此我体验过的网络速度有了数量级上的飞跃。</p><p><img src="https://file.qh2333.com/blog_cache/upgrading-to-gigabit-lan/speedtest_in_sg.jpg" alt="P4. 国外网速" width="50%"/></p><p>本来还在可惜回国以后就享受不到又快又好的网络了，没想到回国的第二天移动给我打了个电话，说是家里的网络可以以非常便宜的价格升级到200M。有这种机会当然是不能错过的，移动的工程师第三天就到了我们家里来（感谢提速降费！）。</p><p>经过一番升级，入户宽带提升到了<strong>200M</strong>、有线猫换成了<strong>光猫</strong>、客厅路由器换成了<strong>华为WS5200增强版</strong>。客厅的老路由器运行不太稳定，直接被我扔了。</p><p><img src="https://file.qh2333.com/blog_cache/upgrading-to-gigabit-lan/Topology3.svg" alt="P5. 网络拓扑3.0"/></p><p>新的路由器同时支持2.4GHz频段和5GHz频段。在可以直视路由器的地方，200M的网速妥妥的；只要一隔着墙，由于无线网卡老化和穿墙两重因素的影响，实际体验感人。2.4GHz的信号可以稳定穿墙，但是速率大打折扣，200M变成20M；5GHz的信号过了堵墙就变得虚无缥缈了，实际体验比2.4GHz下更糟糕。</p><p>暑假在家时间很短，还没有来得及处理这个问题就返校了。</p><h2 id="参数起底">参数起底</h2><p>大二下学期学完了计网，加上寒假回家后由于新冠疫情的问题只能在家里呆着，糟糕的网络情况让人烦躁，所以直到最近我才真正着手升级家里的局域网。</p><p>我的首要升级目标是在全家范围内实现千兆互联。在这之前，我需要对家里的所有网络设备有一个细致的了解。</p><h3 id="爆款无线路由器">爆款无线路由器</h3><p>我最先关注到的是爆款无线路由器，这个设备很早以前就存在了，十分可疑。路由器的型号是<code>TL-WR886N</code>，说实话名字不怎么吉利。打开TP-LINK的<a href="https://www.tp-link.com.cn/product_397.html#productSpe" target="_blank" rel="noopener">产品介绍页</a>，我们可以看到这款路由器支持的无线协议是<code>802.11b/g/n</code>，也就是非常标准的<code>Wi-Fi 4</code>；支持的有线协议是<code>802.3u</code>，也就是<code>100Mbps</code>以太网。查看维基百科的<a href="https://zh.wikipedia.org/wiki/IEEE_802.11#%E5%90%84%E5%9B%BD%E9%80%82%E7%94%A8%E9%A2%91%E9%81%93" target="_blank" rel="noopener">IEEE 802.11条目</a>，发现<code>802.11n</code>下一条流的最大速率是<code>150Mbps</code>，原来标称的450M网速是通过三根天线进行<code>3*3 MIMO</code>达到的。</p><p>这路由器简直可以进入迷惑行为大赏！有线连接最高速率只有<code>100Mbps</code>，但是无线连接的速率却到了<code>450Mbps</code>，也不知道我的无线设备们怎么才能用完这四倍于有线的无线速率，难道天天在手机之间互相拷贝文件吗。当然，前面的吐槽是建立在设备能达到标称速率的基础上的，实际上我不管用什么设备去连接这个路由器，最高都只能达到<code>72Mbps</code>，也就是<code>20MHz</code>的频带下<code>1*1 MIMO</code>的速度。</p><p>由于有线连接上的速率限制，加上不支持<code>Wi-Fi 5</code>，这款老设备肯定是无法满足千兆网络的要求的，所以我也只能对<code>TL-WR886N</code>说一声886。</p><h3 id="移动无线路由光猫">移动无线路由光猫</h3><p>移动送的光猫虽然是新设备，但是行为也十分可疑。猫的型号是<code>ZXHN F663NV3a</code>，是中兴为中国移动提供的定制型号，在转换光信号之外还支持了无线路由器的功能。看起来买一送一是赚爆，但真相总是男默女泪。</p><p>首先登陆进这个光猫，不得不说在0202年看到下面这种登陆界面，视觉冲击力满分。</p><p><img src="https://file.qh2333.com/blog_cache/upgrading-to-gigabit-lan/ZXHN.png" alt="P6. 光猫登陆界面" width="50%"/></p><p>默认的用户名和密码在光猫底部，进去以后兜兜转转看了半天，实在不知道光猫里除了<code>Wi-Fi SSID</code>还有什么东西能让我设置。当然，这台光猫的迷惑行为远不止这一处。</p><p>由于光猫包含了路由器的功能，所以背部就像普通路由器那样，是有四个LAN口的。千兆光猫的LAN口总应该是全千兆了吧，事实证明我naive了，因为四个LAN口只有一个是千兆的，剩下三个都是百兆的。</p><p>光猫自带的Wi-Fi功能倒是不比前面的爆款路由器差多少，支持<code>Wi-Fi 4</code>标准、最高<code>2*2 MIMO</code>，偶尔能有<code>150M</code>的连接速度。</p><p>我寻思这光猫节约成本的方式也是让人叹为观止。但是回过头来想，这种配置好像<del>大部分家庭的需求都是无法满足的，那又何苦在里面花钱内置路由器呢，实在疑惑。</del> 我错了，大部分家庭不会在意这些东西。</p><h3 id="华为ws5200增强版">华为WS5200增强版</h3><p>滑稽为这款路由器是移动的宽带工程师推销给我的，当时急着想体验<code>200M</code>的网络就买了，价格合理实际体验也让人满意。</p><p>路由器背板上的网线接口是全千兆的；而无线方面，路由器一共配备了四根天线，<code>2.4GHz</code>和<code>5GHz</code>各两根，所以总的无线速率是<code>2*150Mbps+2*433Mbps=1167Mbps</code>（尽管我觉得这种标识有夸大之嫌，但没办法大家都这么标），我的手机和电脑在<code>5GHz</code>的<code>Wi-Fi 5</code>下也都能享受到<code>2*433Mbps=866Mbps</code>的速率。</p><h2 id="升级">升级</h2><p>升级的思路是优先满足<strong>千兆速率</strong>和<strong>全家覆盖</strong>两个要求，允许的情况下我还希望能实现<strong>设备互访</strong>和<strong>无线漫游</strong>。</p><p>一番规划后，我决定使用一台<strong>新路由器</strong>和一台<strong>千兆交换机</strong>实现速率和覆盖的要求。</p><p>前面弃用老路由器的决定导致家里网络覆盖面积少了一半，所以我首先需要购置一台新的路由器来满足网络的全家覆盖（什么，你说AP？那也太贵了！）。洋垃圾路由器是我中意很久的一个选择，在学校里就有人买了一台网件洋垃圾，强大的功能给我留下了深刻的印象。最终我选择了<code>Cisco EA6700</code>这一型号，国际大厂、老板代刷梅林固件、只要250多，是真的赚。</p><p>同时为了解决隔墙Wi-Fi衰减的问题，我直接把华为路由器搬到了次卧，通过墙内走线连上光猫唯一的千兆口，一次性解决次卧内的网络连接问题（再次辱骂施工队留下的混乱信息箱）。至于客厅的无线网，就暂时用光猫上的Wi-Fi了。</p><p>由于光猫上唯一的千兆口被占用，要让新购买的路由器也能享受千兆速率只能再增加一个千兆交换机。狗东上搜索出来一个H3C的桌面五口全千兆交换机，正好打折百元入手。</p><p>硬件升级完后，家里的网络拓扑变成了这个样子。</p><p><img src="https://file.qh2333.com/blog_cache/upgrading-to-gigabit-lan/Topology4.svg" alt="P7. 网络拓扑4.0"/></p><p>拿<code>ipref3</code>测试了一下网速，有线速度全部在<code>950Mbps</code>左右，主卧和次卧的无线连接速度在<code>250~350Mbps</code>，都属于正常范围（为什么有线都不能到1Gbps？当然是因为<a href="https://blog.qh2333.com/2020/03/11/network-myth/#%E5%A7%8B%E7%BB%88%E8%BE%BE%E4%B8%8D%E5%88%B0%E6%A0%87%E7%A7%B0%E9%80%9F%E7%8E%87%E7%9A%84%E7%BD%91%E7%BB%9C">overhead</a>啦！）。</p><p>至于设备互访，我们通常有两种方案。高级的方法当然是在路由器上设置静态路由，这样可以让子网间互不干扰。可事实上三个路由器中只有<code>Cisco EA6700</code>可以让我这么设置，所以这个方法行不通。</p><p>第二种方法是把路由器设置为<strong>桥接模式</strong>（相当于弃用路由功能，把路由器变成<strong>交换机和AP</strong>的组合体），正巧<code>Cisco EA6700</code>和<code>华为WS5200</code>都有快捷的桥接模式开关，一键设置完成。这样设置后，家里相当于只剩下了三个交换机，整个网络合并成了一个子网，自然任意两个设备都能互访。</p><p><img src="https://file.qh2333.com/blog_cache/upgrading-to-gigabit-lan/Topology4.1.svg" alt="P8. 网络拓扑4.1"/></p><p>另外这还带来一个好处：由于两个二级路由的<code>DHCP服务器</code>都被关闭，所以所有设备的IP地址都由光猫分配（只有你不能设置关闭DHCP好吗！要能关我肯定让洋垃圾路由器负责DHCP！）。同一个设备拿着同一个MAC地址在全家任意地方接入，都会分配到固定的IP地址。</p><p>关于设备漫游，这套硬件的确是实现不了。虽然看起来整个网络中有唯一的<code>DHCP服务器</code>，并且可以通过把所有AP的SSID和密码设置为相同的值来实现手机的自动选网，但这种方案会因为各种原因导致体验糟糕。目前实用的方案有<code>AC+AP</code>和<code>Mesh</code>两种，这两种都是土豪方案并不适合我，这里就不介绍了。</p><h2 id="后记">后记</h2><p>花了一周时间和350块把家里的网络从百兆一部升级到了千兆。尽管这套方案还有一些小问题，但是这也让我十分舒适了。</p><p>下面的话，我可能会在交换机和光猫之间加再一级路由器，用来接管整个网络的IP分配，毕竟现在的光猫DHCP完全不受我控制。这级新的路由器上还能部署代理和离线下载等服务，扩展整个局域网的服务提供能力。</p><hr /><p><strong>2020/03/11</strong></p><ul><li>做了一些微小的修改工作</li></ul><p><strong>2020/02/14</strong></p><ul><li>发布这篇文章</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百兆网线遇见千兆入户。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络" scheme="https://blog.qh2333.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
